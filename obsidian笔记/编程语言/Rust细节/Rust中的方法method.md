# Rust方法（Method）知识点阅读笔记

## 一、方法基础概念
### 1.1 方法定义
• **语法结构**：使用`impl`关键字为结构体/枚举实现方法
```rust
impl StructName {
    fn method_name(&self) -> ReturnType { ... }
}
```
• **调用方式**：实例.method_name()
• **对比函数**：`object.method()` vs `function(object)`
• **特点**：与数据分离（方法定义与结构体定义解耦）

### 1.2 self参数
| 形式        | 所有权        | 使用场景                 |
|-----------|-------------|----------------------|
| `self`    | 转移所有权      | 需要消费实例（较少使用）         |
| `&self`   | 不可变借用      | 只读访问数据（最常见）          |
| `&mut self` | 可变借用       | 需要修改实例数据             |
| **本质**   | `self: Self`的语法糖 | 方法第一个参数必须包含self相关类型 |

### 1.3 关联函数
• **定义**：没有self参数的函数（类似静态方法）
• **用途**：
  • 构造器模式（惯例使用`new`命名）
  • 工具函数/工厂模式
• **调用方式**：`StructName::function_name()`
```rust
impl Circle {
    fn new(x: f64, y: f64, r: f64) -> Self {
        Circle { x, y, radius: r }
    }
}
```

## 二、方法高级特性
### 2.1 自动引用/解引用
• **工作机制**：编译器自动添加`&`、`&mut`或`*`使对象与方法签名匹配
• **示例等价性**：
  ```rust
  p1.distance(&p2);    // 直接调用
  (&p1).distance(&p2); // 编译器自动转换
  ```
• **优势**：简化方法调用，隐藏指针操作细节

### 2.2 方法重载
• **字段同名方法**：允许方法名与结构体字段同名（常见于getter）
```rust
impl Rectangle {
    fn width(&self) -> u32 { self.width }
}
// 调用：rect.width() 方法 vs rect.width 字段
```
• **访问控制**：结合pub修饰符实现封装
  • 字段设为私有，通过公有方法访问
  • 强制数据校验/计算属性

### 2.3 多参数方法
```rust
impl Rectangle {
    fn can_hold(&self, other: &Self) -> bool {
        self.width > other.width && self.height > other.height
    }
}
```
• **参数传递**：遵循常规借用规则
• **类型明确**：利用Self关键字保持类型一致性

## 三、特殊实现形式
### 3.1 枚举方法
• **实现方式**：与结构体方法语法一致
```rust
impl Message {
    fn call(&self) {
        match self {
            Message::Write(text) => println!("Text: {}", text),
            // 其他变体处理...
        }
    }
}
```
• **模式匹配**：在方法内通过match处理不同枚举变体

### 3.2 多个impl块
• **代码组织**：允许为同一类型定义多个impl块
• **优势**：
  • 分组相关方法
  • 条件编译
  • trait实现分离
```rust
impl Rectangle {
    // 计算相关方法
}

impl Rectangle {
    // 几何判断方法
}
```

## 四、设计模式实践
### 4.1 构造器模式
• **惯例**：`new`作为默认构造器名称（非关键字）
• **优势**：
  • 统一初始化接口
  • 支持必选参数校验
  • 灵活处理默认值
```rust
impl Rectangle {
    pub fn new(w: u32, h: u32) -> Self {
        assert!(w > 0 && h > 0);
        Self { width: w, height: h }
    }
}
```

### 4.2 Getter模式
• **封装实践**：
  ```rust
  pub struct Rectangle {
      width: u32,  // 私有字段
      height: u32,
  }
  
  impl Rectangle {
      pub fn width(&self) -> u32 { self.width }
  }
  ```
• **优势**：
  • 保持字段私有
  • 后续可添加验证逻辑
  • 兼容性保障

## 五、底层机制
### 5.1 内存安全保证
• **所有权系统**：通过self参数形式自动管理
  • `&self`确保并行读取安全
  • `&mut self`保证独占写入
• **生命周期**：隐式处理方法中的引用生命周期

### 5.2 性能特性
• **零成本抽象**：方法调用在编译期静态分发
• **内联优化**：编译器可根据情况内联方法

## 六、最佳实践
1. **优先使用方法**而非独立函数，提高代码内聚性
2. **合理使用关联函数**处理类型级别的操作
3. **getter方法**与字段同名时需明确区分调用方式
4. **复杂初始化**使用构造器模式而非直接暴露字段
5. **大类型**考虑使用`&self`避免所有权转移

## 七、常见误区
1. **混淆方法与函数**：注意`::`与`.`调用方式的区别
2. **错误使用self所有权**：非必要情况避免使用`self`
3. **过度使用公有字段**：优先通过方法暴露数据
4. **忽略自动解引用**：手动添加多余`*`操作符
5. **线程安全误用**：`&mut self`不自动保证线程安全

通过系统掌握Rust方法机制，可以编写出既安全又符合工程实践的高质量代码。方法的合理使用是Rust面向数据编程范式的重要体现，需要结合所有权系统和类型系统深入理解。