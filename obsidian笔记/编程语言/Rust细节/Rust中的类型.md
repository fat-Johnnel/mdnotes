## 基本数据类型-原生类型（primitives）

### 1.标量类型
- 有符号整数（signed integers）：i8、i16、i32、i64、i128 和 isize（指针宽度）
- 无符号整数（unsigned integers）：u8、u16、u32、u64、u128 和 usize（指针宽度）
- 浮点数（floating point）：f32、f64
- char（字符）：单个 Unicode 字符，如 'a'，'α' 和 '∞'（每个都是 4 字节）
- bool（布尔型）：只能是 true 或 false
- 单元类型（unit type）：()`。其唯一可能的值就是 `()` 这个空元组
- 字符串：字符串字面量和字符串切片`&str`

### 2.复合类型
- 数组（array）：如 `[1, 2, 3]`
- 元组（tuple）：如 `(1, true)`


### 3.整数类型
#### 整形溢出
在`debug`模式下运行时会检查溢出，在`--release`下则不会

要**显式处理可能的溢出**，可以使用标准库针对原始数字类型提供的这些方法：

- 使用 `wrapping_*` 方法在所有模式下都按照补码循环溢出规则处理，例如 `wrapping_add`
- 如果使用 `checked_*` 方法时发生溢出，则返回 `None` 值
- 使用 `overflowing_*` 方法返回该值和一个指示是否存在溢出的布尔值
- 使用 `saturating_*` 方法，可以限定计算后的结果不超过目标类型的最大值或低于最小值，例如:
```rust
fn main() {
    let a : u8 = 255;
    let b = a.wrapping_add(20);
    println!("{}", b);  // 19

    assert_eq!(100u8.saturating_add(1), 101);
	assert_eq!(u8::MAX.saturating_add(127), u8::MAX);
}
```

### 4.浮点数
#### 浮点数陷阱
浮点数由于底层格式的特殊性，导致了如果在使用浮点数时不够谨慎，就可能造成危险，有两个原因：

1. **浮点数往往是你想要数字的近似表达** 浮点数类型是基于二进制实现的，但是我们想要计算的数字往往是基于十进制，例如 `0.1` 在二进制上并不存在精确的表达形式，但是在十进制上就存在。这种不匹配性导致一定的歧义性，更多的，虽然浮点数能代表真实的数值，但是由于底层格式问题，它往往受限于定长的浮点数精度，如果你想要表达完全精准的真实数字，只有使用无限精度的浮点数才行
    
2. **浮点数在某些特性上是反直觉的** 例如大家都会觉得浮点数可以进行比较，对吧？是的，它们确实可以使用 `>`，`>=` 等进行比较，但是在某些场景下，这种直觉上的比较特性反而会害了你。因为 `f32` ， `f64` 上的比较运算实现的是 `std::cmp::PartialEq` 特征(类似其他语言的接口)，但是并没有实现 `std::cmp::Eq` 特征，但是后者在其它数值类型上都有定义，说了这么多，可能大家还是云里雾里，用一个例子来举例：
    

Rust 的 `HashMap` 数据结构，是一个 KV 类型的 Hash Map 实现，它对于 `K` 没有特定类型的限制，但是要求能用作 `K` 的类型必须实现了 `std::cmp::Eq` 特征，因此这意味着你无法使用浮点数作为 `HashMap` 的 `Key`，来存储键值对，但是作为对比，Rust 的整数类型、字符串类型、布尔类型都实现了该特征，因此可以作为 `HashMap` 的 `Key`。

为了避免上面说的两个陷阱，你需要遵守以下准则：

- 避免在浮点数上测试相等性
- 当结果在数学上可能存在未定义时，需要格外的小心

#### NaN
对于数学上未定义的结果，例如对负数取平方根 `-42.1.sqrt()` ，会产生一个特殊的结果：Rust 的浮点数类型使用 `NaN` (not a number) 来处理这些情况。

**所有跟 `NaN` 交互的操作，都会返回一个 `NaN`**，而且 `NaN` 不能用来比较，下面的代码会崩溃：
```rust
fn main() {
  let x = (-42.0_f32).sqrt();
  assert_eq!(x, x);
}
```

出于防御性编程的考虑，可以使用 `is_nan()` 等方法，可以用来判断一个数值是否是 `NaN` ：
```rust
fn main() {
    let x = (-42.0_f32).sqrt();
    if x.is_nan() {
        println!("未定义的数学行为")
    }
}
```

### 5.有关数组
#### Rust 数组类型详解

#### 一、数组基本特性

1. ​**固定长度**  
   数组长度在编译时确定，声明后不可改变。例如 `[i32; 5]` 表示包含5个整数的数组，适合需要精确内存控制的场景（如硬件编程）。

2. ​**同构元素**  
   所有元素必须为相同类型，`[1, "a"]` 会因类型不匹配导致编译错误。

3. ​**栈内存分配**  
   默认存储在栈上（除非包含堆元素），访问速度比动态数组（`Vec`）更快。

#### 二、数组声明与初始化

```rust
// 显式类型声明
let numbers: [i32; 5] = [1, 2, 3, 4, 5];

// 快捷初始化（10个0）
let zeros = [0; 10];  // 等价于 [0,0,0,0,0,0,0,0,0,0]

// 多维数组（3x2矩阵）
let matrix: [[i32; 3]; 2] = [[1, 2, 3], [4, 5, 6]];
```


### 6.有关元组
### Rust 元组类型详解

#### 一、元组基本特性

1. ​**固定长度**  
   元组长度在声明时确定，不可动态增减。例如 `(i32, f64)` 表示包含整数和浮点数的二元组。

2. ​**异构元素**  
   允许存储不同类型的数据，例如 `(1, 3.14, "hello")` 包含 `i32`, `f64`, `&str` 三种类型。

3. ​**栈内存分配**  
   与数组类似，元组默认存储在栈上，访问效率高。

---

#### 二、元组声明与初始化

```rust
// 类型自动推断
let tuple1 = (10, 3.14, "Rust");  // 类型为 (i32, f64, &str)

// 显式类型注解
let tuple2: (bool, char, [i32; 3]) = (true, 'A', [1,2,3]);

// 空元组（单元类型）
let unit = ();  // 用于表示无返回值的情况
```

### 7.数字运算
以下是一个综合性的示例：
```rust
fn main() {
  // 编译器会进行自动推导，给予twenty i32的类型
  let twenty = 20;
  // 类型标注
  let twenty_one: i32 = 21;
  // 通过类型后缀的方式进行类型标注：22是i32类型
  let twenty_two = 22i32;

  // 只有同样类型，才能运算
  let addition = twenty + twenty_one + twenty_two;
  println!("{} + {} + {} = {}", twenty, twenty_one, twenty_two, addition);

  // 对于较长的数字，可以用_进行分割，提升可读性
  let one_million: i64 = 1_000_000;
  println!("{}", one_million.pow(2));

  // 定义一个f32数组，其中42.0会自动被推导为f32类型
  let forty_twos = [
    42.0,
    42f32,
    42.0_f32,
  ];

  // 打印数组中第一个值，并控制小数位为2位
  println!("{:.2}", forty_twos[0]);
}
```

#### 位运算
|运算符|说明|
|---|---|
|& 位与|相同位置均为1时则为1，否则为0|
|\| 位或|相同位置只要有1时则为1，否则为0|
|^ 异或|相同位置不相同则为1，相同则为0|
|! 位非|把位中的0和1相互取反，即0置为1，1置为0|
|<< 左移|所有位向左移动指定位数，右位补0|
|>> 右移|所有位向右移动指定位数，带符号移动（正数补0，负数补1）|
对于移位运算，Rust 会检查它**是否超出该整型的位数范围**，如果超出，则会报错 overflow。比如，一个 8 位的整型，如果试图移位 8 位，就会报错，但如果移位 7 位就不会。Rust 这样做的理由也很简单，如果移位太多，那么这个移位后的数字就是全 0 或者全 1，所以移位操作不如直接写 0 或者 -1，这很可能意味着这里的代码是有问题的。需要注意的是，不论 debug 模式还是 release 模式，Rust 都会检查溢出。

### 7.序列
Rust 提供了一个非常简洁的方式，用来生成连续的数值，例如 `1..5`，生成从 1 到 4 的连续数字，不包含 5 ；`1..=5`，生成从 1 到 5 的连续数字，包含 5，它的用途很简单，常常用于循环中
序列只允许用于**数字或字符类型**，原因是：它们可以连续，同时编译器在编译期可以检查该序列是否为空，字符和数字值是 Rust 中仅有的可以用于判断是否为空的类型。

[[Rust中的字符、布尔、单元类型]]